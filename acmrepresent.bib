
@inproceedings{yang_self-supervised_2022,
	address = {New York, NY, USA},
	series = {{ICPC} '22},
	title = {Self-{Supervised} {Learning} of {Smart} {Contract} {Representations}},
	isbn = {978-1-4503-9298-3},
	url = {https://doi.org/10.1145/3524610.3527894},
	doi = {10.1145/3524610.3527894},
	abstract = {Learning smart contract representations can greatly facilitate the development of smart contracts in many tasks such as bug detection and clone detection. Existing approaches for learning program representations are difficult to apply to smart contracts which have insufficient data and significant homogenization. To overcome these challenges, in this paper, we propose SRCL, a novel, self-supervised approach for learning smart contract representations. Unlike existing supervised methods, which are tied on task-specific data labels, SRCL leverages large-scale unlabeled data by self-supervised learning of both local and global information of smart contracts. It automatically extracts structural sequences from abstract syntax trees (ASTs). Then, two discriminators are designed to guide the Transformer encoder to learn local and global semantic features of smart contracts. We evaluate SRCL on a dataset of 75,006 smart contracts collected from Etherscan. Experimental results show that SRCL considerably outperforms the state-of-the-art code representation models on three downstream tasks.},
	booktitle = {Proceedings of the 30th {IEEE}/{ACM} {International} {Conference} on {Program} {Comprehension}},
	publisher = {Association for Computing Machinery},
	author = {Yang, Shouliang and Gu, Xiaodong and Shen, Beijun},
	year = {2022},
	note = {event-place: Virtual Event},
	keywords = {smart contract, code representation learning, data augmentation, self-supervised learning},
	pages = {82--93},
}

@inproceedings{chen_declarative_2022,
	address = {New York, NY, USA},
	series = {{ESEC}/{FSE} 2022},
	title = {Declarative {Smart} {Contracts}},
	isbn = {978-1-4503-9413-0},
	url = {https://doi.org/10.1145/3540250.3549121},
	doi = {10.1145/3540250.3549121},
	abstract = {This paper presents DeCon, a declarative programming language for implementing smart contracts and specifying contract-level properties. Driven by the observation that smart contract operations and contract-level properties can be naturally expressed as relational constraints, DeCon models each smart contract as a set of relational tables that store transaction records. This relational representation of smart contracts enables convenient specification of contract properties, facilitates run-time monitoring of potential property violations, and brings clarity to contract debugging via data provenance. Specifically, a DeCon program consists of a set of declarative rules and violation query rules over the relational representation, describing the smart contract implementation and contract-level properties, respectively. We have developed a tool that can compile DeCon programs into executable Solidity programs, with instrumentation for run-time property monitoring. Our case studies demonstrate that DeCon can implement realistic smart contracts such as ERC20 and ERC721 digital tokens. Our evaluation results reveal the marginal overhead of DeCon compared to the open-source reference implementation, incurring 14\% median gas overhead for execution, and another 16\% median gas overhead for run-time verification.},
	booktitle = {Proceedings of the 30th {ACM} {Joint} {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}},
	publisher = {Association for Computing Machinery},
	author = {Chen, Haoxian and Whitters, Gerald and Amiri, Mohammad Javad and Wang, Yuepeng and Loo, Boon Thau},
	year = {2022},
	note = {event-place: Singapore, Singapore},
	keywords = {Smart contracts, Declarative programming, Run-time verification},
	pages = {281--293},
}

@inproceedings{hu_empirical_2022,
	address = {New York, NY, USA},
	series = {{ICPC} '22},
	title = {An {Empirical} {Investigation} on the {Trade}-off between {Smart} {Contract} {Readability} and {Gas} {Consumption}},
	isbn = {978-1-4503-9298-3},
	url = {https://doi.org/10.1145/3524610.3529157},
	doi = {10.1145/3524610.3529157},
	abstract = {Blockchain technology is becoming increasingly popular, and smart contracts (i.e., programs that run on top of the blockchain) represent a crucial element of this technology. In particular, smart contracts running on Ethereum (i.e., one of the most popular blockchain platforms) are often developed with Solidity, and their deployment and execution consume gas (i.e., a fee compensating the computing resources required). Smart contract development frequently involves code reuse, but poor readable smart contracts could hinder their reuse. However, writing readable smart contracts is challenging, since practices for improving the readability could also be in contrast with optimization strategies for reducing gas consumption. This paper aims at better understanding (i) the readability aspects for which traditional software and smart contracts differ, and (ii) the specific smart contract readability features exhibiting significant relationships with gas consumption. We leverage a set of metrics that previous research has proven correlated with code readability. In particular, we first compare the values of these metrics obtained for both Solidity smart contracts and traditional software systems (written in Java). Then, we investigate the correlations occurring between these metrics and gas consumption and between each pair of metrics. The results of our study highlight that smart contracts usually exhibit lower readability than traditional software for what concerns the number of parentheses, inline comments, and blank lines used. In addition, we found some readability metrics (such as the average length of identifiers and the average number of keywords) that significantly correlate with gas consumption.},
	booktitle = {Proceedings of the 30th {IEEE}/{ACM} {International} {Conference} on {Program} {Comprehension}},
	publisher = {Association for Computing Machinery},
	author = {Hu, Xing and Gao, Zhipeng and Xia, Xin and Lo, David and Yang, Xiaohu and Vacca, Anna and Fredella, Michele and Di Sorbo, Andrea and Visaggio, Corrado A. and Canfora, Gerardo},
	year = {2022},
	note = {event-place: Virtual Event},
	keywords = {code quality, empirical study, readability metrics, software engineering for blockchain technologies, software metrics},
	pages = {214--224},
}

@inproceedings{liu_enabling_2019,
	series = {{ICPC} '19},
	title = {Enabling {Clone} {Detection} for {Ethereum} via {Smart} {Contract} {Birthmarks}},
	url = {https://doi.org/10.1109/ICPC.2019.00024},
	doi = {10.1109/ICPC.2019.00024},
	abstract = {The Ethereum ecosystem has introduced a pervasive blockchain platform with programmable transactions. Everyone is allowed to develop and deploy smart contracts. Such flexibility can lead to a large collection of similar contracts, i.e., clones, especially when Ethereum applications are highly domain-specific and may share similar functionalities within the same domain, e.g., token contracts often provide interfaces for money transfer and balance inquiry. While smart contract clones have a wide range of impact across different applications, e.g., security, they are relatively little studied.Although clone detection has been a long-standing research topic, blockchain smart contracts introduce new challenges, e.g., syntactic diversity due to trade-off between storage and execution, understanding high-level business logic etc.. In this paper, we highlighted the very first attempt to clone detection of Ethereum smart contracts. To overcome the new challenges, we introduce the concept of smart contract birthmark, i.e., a semantic-preserving and computable representation for smart contract bytecode. The birthmark captures high-level semantics by effectively sketching symbolic execution traces (e.g., data access dependencies, path conditions) and maintain syntactic regularities (e.g., type and number of instructions) as well. Then, the clone detection problem is reduced to a computation of statistical similarity between two contract birthmarks. We have implemented a clone detector called EClone and evaluated it on Ethereum. The empirical results demonstrated the potential of EClone in accurately identifying clones. We have also extended EClone for vulnerability search and managed to detect CVE-2018-10376 instances.},
	booktitle = {Proceedings of the 27th {International} {Conference} on {Program} {Comprehension}},
	publisher = {IEEE Press},
	author = {Liu, Han and Yang, Zhiqiang and Jiang, Yu and Zhao, Wenqi and Sun, Jiaguang},
	year = {2019},
	note = {event-place: Montreal, Quebec, Canada},
	keywords = {symbolic execution, ethereum, clone detection, smart contract birthmark},
	pages = {105--115},
}

@inproceedings{medeiros_solunit_2019,
	address = {USA},
	series = {{CASCON} '19},
	title = {{SolUnit}: {A} {Framework} for {Reducing} {Execution} {Time} of {Smart} {Contract} {Unit} {Tests}},
	abstract = {Smart contracts are software programs implemented on a blockchain platform that monitor and automate the execution of contracts to ensure compliance with the terms and conditions of a contract. As such, smart contracts represent a new kind of software that poses its own engineering challenges and requires novel software engineering techniques. In particular, smart contracts require thorough testing before they are deployed because they can't be changed after deployment. This paper proposes a novel approach for executing unit tests for smart contracts intended to reduce test execution time. This reduction is achieved through the reuse of the deployment execution of the smart contract in each test and also the reuse of the setup execution of each test. We implemented the framework SolUnit that uses this approach to execute tests written in Java for Ethereum Solidity smart contracts. We also evaluated the framework SolUnit in five projects. The results show that our approach achieves a meaningful reduction of the time to execute the tests, without breaking the principle of independent tests. The experiments were performed in two environments: an in-memory simulated blockchain and a private Ethereum-based blockchain. Overall, our approach was able to reduce the test execution time by up to 70\%.},
	booktitle = {Proceedings of the 29th {Annual} {International} {Conference} on {Computer} {Science} and {Software} {Engineering}},
	publisher = {IBM Corp.},
	author = {Medeiros, Hallan and Vilain, Patrícia and Mylopoulos, John and Jacobsen, Hans-Arno},
	year = {2019},
	note = {event-place: Toronto, Ontario, Canada},
	keywords = {Ethereum, blockchain, smart contract, software testing, solidity, SolUnit, test automation, testing framework, unit testing},
	pages = {264--273},
}

@article{wang_detecting_2019,
	title = {Detecting {Nondeterministic} {Payment} {Bugs} in {Ethereum} {Smart} {Contracts}},
	volume = {3},
	url = {https://doi.org/10.1145/3360615},
	doi = {10.1145/3360615},
	abstract = {The term “smart contracts” has become ubiquitous to describe an enormous number of programs uploaded to the popular Ethereum blockchain system. Despite rapid growth of the smart contract ecosystem, errors and exploitations have been constantly reported from online contract systems, which has put financial stability at risk with losses totaling millions of US dollars. Most existing research focuses on pinpointing specific types of vulnerabilities using known patterns. However, due to the lack of awareness of the inherent nondeterminism in the Ethereum blockchain system and how it affects the funds transfer of smart contracts, there can be unknown vulnerabilities that may be exploited by attackers to access numerous online smart contracts. In this paper, we introduce a methodical approach to understanding the inherent nondeterminism in the Ethereum blockchain system and its (unwanted) influence on contract payments. We show that our new focus on nondeterminism-related smart contract payment bugs captures the root causes of many common vulnerabilities without relying on any known patterns and also encompasses recently disclosed issues that are not handled by existing research. To do so, we introduce techniques to systematically model components in the contract execution context and to expose various nondeterministic factors that are not yet fully understood. We further study how these nondeterministic factors impact contract funds transfer using information flow tracking. The technical challenge of detecting nondeterministic payments lies in discovering the contract global variables subtly affected by read-write hazards because of unpredictable transaction scheduling and external callee behavior. We show how to augment and instrument a contract program into a representation that simulates the execution of a large subset of the contract behavior. The instrumented code is then analyzed to flag nondeterministic global variables using off-the-shelf model checkers. We implement the proposed techniques as a practical tool named NPChecker (Nondeterministic Payment Checker) and evaluate it on 30K online contracts (3,075 distinct) collected from the Ethereum mainnet. NPChecker has successfully detected nondeterministic payments in 1,111 online contracts with reasonable cost. Further investigation reports high precision of NPChecker (only four false positives in a manual study of 50 contracts). We also show that NPChecker unveils contracts vulnerable to recently-disclosed attack vectors. NPChecker can identify all six new vulnerabilities or variants of common smart contract vulnerabilities that are missed by existing research relying on a “contract vulnerability checklist.”},
	number = {OOPSLA},
	journal = {Proc. ACM Program. Lang.},
	author = {Wang, Shuai and Zhang, Chengyu and Su, Zhendong},
	month = oct,
	year = {2019},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Blockchain, Smart Contracts, Program Analysis, Security},
}

@article{grech_elipmoc_2022,
	title = {Elipmoc: {Advanced} {Decompilation} of {Ethereum} {Smart} {Contracts}},
	volume = {6},
	url = {https://doi.org/10.1145/3527321},
	doi = {10.1145/3527321},
	abstract = {Smart contracts on the Ethereum blockchain greatly benefit from cutting-edge analysis techniques and pose significant challenges. A primary challenge is the extremely low-level representation of deployed contracts. We present Elipmoc, a decompiler for the next generation of smart contract analyses. Elipmoc is an evolution of Gigahorse, the top research decompiler, dramatically improving over it and over other state-of-the-art tools, by employing several high-precision techniques and making them scalable. Among these techniques are a new kind of context sensitivity (termed “transactional sensitivity”) that provides a more effective static abstraction of distinct dynamic executions; a path-sensitive (yet scalable, through path merging) algorithm for inference of function arguments and returns; and a fully context sensitive private function reconstruction process. As a result, smart contract security analyses and reverse-engineering tools built on top of Elipmoc achieve high scalability, precision and completeness. Elipmoc improves over all notable past decompilers, including its predecessor, Gigahorse, and the state-of-the-art industrial tool, Panoramix, integrated into the primary Ethereum blockchain explorer, Etherscan. Elipmoc produces decompiled contracts with fully resolved operands at a rate of 99.5\% (compared to 62.8\% for Gigahorse), and achieves much higher completeness in code decompilation than Panoramix—e.g., up to 67\% more coverage of external call statements—while being over 5x faster. Elipmoc has been the enabler for recent (independent) discoveries of several exploitable vulnerabilities on popular protocols, over funds in the many millions of dollars.},
	number = {OOPSLA1},
	journal = {Proc. ACM Program. Lang.},
	author = {Grech, Neville and Lagouvardos, Sifis and Tsatiris, Ilias and Smaragdakis, Yannis},
	month = apr,
	year = {2022},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {Blockchain, Ethereum, Smart Contracts, Datalog, Decompilation, Program Analysis, Security},
}

@inproceedings{guidi_sleepminting_2022,
	address = {New York, NY, USA},
	series = {{GoodIT} '22},
	title = {Sleepminting, the {Brand} {New} {Frontier} of {Non} {Fungible} {Tokens} {Fraud}},
	isbn = {978-1-4503-9284-6},
	url = {https://doi.org/10.1145/3524458.3547239},
	doi = {10.1145/3524458.3547239},
	abstract = {Non Fungible Tokens (NFTs) are becoming a standard to represent unique and valuable items, such as a piece of art, a videogame item, or other digital or physical goods, and keep track of their provenance. Thanks to blockchain technology and the power of smart contracts, NFT holders have true ownership over them, because they are the only ones who can transfer them. However, through an attack called sleepminting, an attacker is able to impersonate another person, including an artist, and create NFTs on the artist’s behalf, while still maintaining its possession, leveraging bugs in the code of the smart contract that manages the NFTs. Therefore, the attacker can cheat concerning the provenance of an NFT and then sell the fake NFTs to unaware buyers. In this paper, we propose a study that sheds light on this phenomenon. In particular, we collect over 1.3 million events that are connected to sleepminting and analyse the events under multiple aspects. The study uncovers that, by using the sleepminting attack, some users are able to create fake NFTs of popular brands, and are able to mint them to famous personalities in the NFT field, such as well known artists and collectors.},
	booktitle = {Proceedings of the 2022 {ACM} {Conference} on {Information} {Technology} for {Social} {Good}},
	publisher = {Association for Computing Machinery},
	author = {Guidi, Barbara and Michienzi, Andrea},
	year = {2022},
	note = {event-place: Limassol, Cyprus},
	keywords = {Blockchain, Smart contract, Non fungible token},
	pages = {75--81},
}

@inproceedings{li_poster_2022,
	address = {New York, NY, USA},
	series = {{CCS} '22},
	title = {Poster: {EOSDFA}: {Data} {Flow} {Analysis} of {EOSIO} {Smart} {Contracts}},
	isbn = {978-1-4503-9450-5},
	url = {https://doi.org/10.1145/3548606.3563545},
	doi = {10.1145/3548606.3563545},
	abstract = {As an efficient blockchain platform, EOSIO is becoming increasingly popular. However, it has exposed many security problems and caused a large amount of financial losses. In the past, the difficulty of collecting open-source EOSIO smart contracts and analyzing WebAssembly (Wasm) bytecode compiled by EOSIO smart contracts, making few researchers proposed static analysis tools for EOSIO smart contracts, and tools capable of dataflow analysis have not yet appeared. In this work, we first propose a dataflow analysis method for EOSIO smart contracts. Based on Octopus, we designed an efficient dataflow analysis method, which can generate Static Single Assignment (SSA) form intermediate representation (IR) for the objective function and its variables to obtain the results of dataflow. We further proved the effectiveness of the proposed method through experiments on our collected data sets.},
	booktitle = {Proceedings of the 2022 {ACM} {SIGSAC} {Conference} on {Computer} and {Communications} {Security}},
	publisher = {Association for Computing Machinery},
	author = {Li, Levi Taiji and Zhang, Mu},
	year = {2022},
	note = {event-place: Los Angeles, CA, USA},
	keywords = {smart contract, data flow analysis, eosio, points-to analysis},
	pages = {3391--3393},
}

@inproceedings{corradini_flexible_2023,
	address = {New York, NY, USA},
	series = {{WETSEB} '22},
	title = {Flexible {Execution} of {Multi}-{Party} {Business} {Processes} on {Blockchain}},
	isbn = {978-1-4503-9331-7},
	url = {https://doi.org/10.1145/3528226.3528369},
	doi = {10.1145/3528226.3528369},
	abstract = {The execution of multi-party business processes on blockchains has been more and more used in the last years in those contexts where trust among the involved parties is a crucial requirement that cannot be assumed by default. The immutability, transparency, and decentralised characteristics of the blockchain ensure the parties' responsibility in case of controversial actions. However, if on the one hand, the immutable nature of the blockchain brings many benefits from the trust perspective, on the other hand such rigidity leads to a lack of flexibility in the execution of blockchain-based business processes.In this paper, we face the challenge of making flexible the execution of multi-party business processes based on blockchain. We propose an approach that exploits the BPMN choreography model to describe a multi-party business process. From the model it is produced an on-chain smart contract storing the current state of the execution, and an off-chain rule-based program implementing the choreography logic. The decoupling of the execution state from the choreography logic allows achieving the flexibility of the multi-party interactions.We provide an implementation of the approach, the FlexChain framework, that relies on the Ethereum permissionless blockchain, hence on Solidity smart contracts, and on Drools as an off-chain rules engine. We assess the feasibility and effectiveness of the proposed solution through a case study representing the procedure for a career upgrade, whose experiments have been conducted on the Rinkeby Ethereum Testnet.},
	booktitle = {Proceedings of the 5th {International} {Workshop} on {Emerging} {Trends} in {Software} {Engineering} for {Blockchain}},
	publisher = {Association for Computing Machinery},
	author = {Corradini, Flavio and Marcelletti, Alessandro and Morichetta, Andrea and Polini, Andrea and Re, Barbara and Tiezzi, Francesco},
	year = {2023},
	note = {event-place: Pittsburgh, Pennsylvania},
	keywords = {blockchain, BPMN, choreography, flexibility},
	pages = {25--32},
}

@inproceedings{grech_gigahorse_2019,
	series = {{ICSE} '19},
	title = {Gigahorse: {Thorough}, {Declarative} {Decompilation} of {Smart} {Contracts}},
	url = {https://doi.org/10.1109/ICSE.2019.00120},
	doi = {10.1109/ICSE.2019.00120},
	abstract = {The rise of smart contracts—autonomous applications running on blockchains—has led to a growing number of threats, necessitating sophisticated program analysis. However, smart contracts, which transact valuable tokens and cryptocurrencies, are compiled to very low-level bytecode. This bytecode is the ultimate semantics and means of enforcement of the contract.We present the Gigahorse toolchain. At its core is a reverse compiler (i.e., a decompiler) that decompiles smart contracts from Ethereum Virtual Machine (EVM) bytecode into a high-level 3-address code representation. The new intermediate representation of smart contracts makes implicit data- and control-flow dependencies of the EVM bytecode explicit. Decompilation obviates the need for a contract's source and allows the analysis of both new and deployed contracts.Gigahorse advances the state of the art on several fronts. It gives the highest analysis precision and completeness among decompilers for Ethereum smart contracts—e.g., Gigahorse can decompile over 99.98\% of deployed contracts, compared to 88\% for the recently-published Vandal decompiler and under 50\% for the state-of-the-practice Porosity decompiler. Importantly, Gigahorse offers a full-featured toolchain for further analyses (and a "batteries included" approach, with multiple clients already implemented), together with the highest performance and scalability. Key to these improvements is Gigahorse's use of a declarative, logic-based specification, which allows high-level insights to inform low-level decompilation.},
	booktitle = {Proceedings of the 41st {International} {Conference} on {Software} {Engineering}},
	publisher = {IEEE Press},
	author = {Grech, Neville and Brent, Lexi and Scholz, Bernhard and Smaragdakis, Yannis},
	year = {2019},
	note = {event-place: Montreal, Quebec, Canada},
	keywords = {blockchain, ethereum, decompilation, program analysis},
	pages = {1176--1186},
}

@inproceedings{feist_slither_2019,
	series = {{WETSEB} '19},
	title = {Slither: {A} {Static} {Analysis} {Framework} for {Smart} {Contracts}},
	url = {https://doi.org/10.1109/WETSEB.2019.00008},
	doi = {10.1109/WETSEB.2019.00008},
	abstract = {This paper describes Slither, a static analysis framework designed to provide rich information about Ethereum smart contracts. It works by converting Solidity smart contracts into an intermediate representation called SlithIR. SlithIR uses Static Single Assignment (SSA) form and a reduced instruction set to ease implementation of analyses while preserving semantic information that would be lost in transforming Solidity to bytecode. Slither allows for the application of commonly used program analysis techniques like dataflow and taint tracking. Our framework has four main use cases: (1) automated detection of vulnerabilities, (2) automated detection of code optimization opportunities, (3) improvement of the user's understanding of the contracts, and (4) assistance with code review.In this paper, we present an overview of Slither, detail the design of its intermediate representation, and evaluate its capabilities on real-world contracts. We show that Slither's bug detection is fast, accurate, and outperforms other static analysis tools at finding issues in Ethereum smart contracts in terms of speed, robustness, and balance of detection and false positives. We compared tools using a large dataset of smart contracts and manually reviewed results for 1000 of the most used contracts.},
	booktitle = {Proceedings of the 2nd {International} {Workshop} on {Emerging} {Trends} in {Software} {Engineering} for {Blockchain}},
	publisher = {IEEE Press},
	author = {Feist, Josselin and Greico, Gustavo and Groce, Alex},
	year = {2019},
	note = {event-place: Montreal, Quebec, Canada},
	pages = {8--15},
}

@inproceedings{khalil_decentralized_2022,
	address = {New York, NY, USA},
	series = {{CCIOT} '22},
	title = {Decentralized {Smart} {City} of {Things}: {A} {Blockchain} {Tokenization}-{Enabled} {Architecture} for {Digitization} and {Authentication} of {Assets} in {Smart} {Cities}},
	isbn = {978-1-4503-9673-8},
	url = {https://doi.org/10.1145/3569507.3569513},
	doi = {10.1145/3569507.3569513},
	abstract = {IoT-enabled smart devices have become an essential part of the smart city architectures, which establishes all the underlying architectures to operate altogether, such as the Internet of Things (IoT), Cyber-Physical Systems (CPSs), Internet of Cyber-Physical Things (IoCPT), and Internet of Everything (IoE). Similarly, these underlying architectures constitute a system to realize the concept of smart cities and, ultimately, a smart planet. A private blockchain-based architecture, Decentralized Smart City of Things (DSCoT), has been proposed in this study which utilizes Blockchain tokenization (i.e., Non-fungible tokens-NFTs) for the representation and authentication of user and IoT assets by defining smart device attributes. Through NFTs, the uniqueness of the IoT assets and users has been realized, which helps digitize these assets as non-interchangeable units of data stored on a digital ledger. The proposed architecture ensures this functionality of unique asset representation by deploying smart contracts and further for IoT assets and user authentication. The mechanism provides security services such as confidentiality, integrity (using SHA-III one-way encryption), availability, and authorization (CIA). The evaluation of the proposed functions and components has been provided in terms of Gas consumption and time complexity, showing promising results. An innovative approach of functions to query the smart contract for the status of assets in the NFT registry offers no transaction cost (in Ether/Gewi), making the proposed extension efficient in terms of time complexity. This architecture aims to provide a smart city solution that may ensure robust security features utilizing Blockchain, NFTs, and SHA-III encryption mechanisms.},
	booktitle = {Proceedings of the 2022 7th {International} {Conference} on {Cloud} {Computing} and {Internet} of {Things}},
	publisher = {Association for Computing Machinery},
	author = {Khalil, Usman and Malik, Owais Ahmed and Hong, Ong Wee and Uddin, Mueen},
	year = {2022},
	note = {event-place: Okinawa, Japan},
	keywords = {Smart contract, IoT, Authentication, Blockchain Tokenization, Cyber-Physical System, Decentralized Ledger Technology, Hyperledger Besu, Private Blockchain, Security Services, SHAIII, Smart City},
	pages = {38--47},
}

@inproceedings{tikhomirov_smartcheck_2018,
	address = {New York, NY, USA},
	series = {{WETSEB} '18},
	title = {{SmartCheck}: {Static} {Analysis} of {Ethereum} {Smart} {Contracts}},
	isbn = {978-1-4503-5726-5},
	url = {https://doi.org/10.1145/3194113.3194115},
	doi = {10.1145/3194113.3194115},
	abstract = {Ethereum is a major blockchain-based platform for smart contracts - Turing complete programs that are executed in a decentralized network and usually manipulate digital units of value. Solidity is the most mature high-level smart contract language. Ethereum is a hostile execution environment, where anonymous attackers exploit bugs for immediate financial gain. Developers have a very limited ability to patch deployed contracts. Hackers steal up to tens of millions of dollars from flawed contracts, a well-known example being "The DAO", broken in June 2016. Advice on secure Ethereum programming practices is spread out across blogs, papers, and tutorials. Many sources are outdated due to a rapid pace of development in this field. Automated vulnerability detection tools, which help detect potentially problematic language constructs, are still underdeveloped in this area.We provide a comprehensive classification of code issues in Solidity and implement SmartCheck - an extensible static analysis tool that detects them1. SmartCheck translates Solidity source code into an XML-based intermediate representation and checks it against XPath patterns. We evaluated our tool on a big dataset of real-world contracts and compared the results with manual audit on three contracts. Our tool reflects the current state of knowledge on Solidity vulnerabilities and shows significant improvements over alternatives. SmartCheck has its limitations, as detection of some bugs requires more sophisticated techniques such as taint analysis or even manual audit. We believe though that a static analyzer should be an essential part of contract developers' toolbox, letting them fix simple bugs fast and allocate more effort to complex issues.},
	booktitle = {Proceedings of the 1st {International} {Workshop} on {Emerging} {Trends} in {Software} {Engineering} for {Blockchain}},
	publisher = {Association for Computing Machinery},
	author = {Tikhomirov, Sergei and Voskresenskaya, Ekaterina and Ivanitskiy, Ivan and Takhaviev, Ramil and Marchenko, Evgeny and Alexandrov, Yaroslav},
	year = {2018},
	note = {event-place: Gothenburg, Sweden},
	keywords = {smart contracts, ethereum, solidity, static analysis, bug detection},
	pages = {9--16},
}

@article{hynes_demonstration_2018,
	title = {A {Demonstration} of {Sterling}: {A} {Privacy}-{Preserving} {Data} {Marketplace}},
	volume = {11},
	issn = {2150-8097},
	url = {https://doi.org/10.14778/3229863.3236266},
	doi = {10.14778/3229863.3236266},
	abstract = {In this work, we demonstrate Sterling, a decentralized marketplace for private data. Sterling enables privacy-preserving distribution and use of data by using privacy-preserving smart contracts which run on a permissionless blockchain. The privacy-preserving smart contracts, written by data providers and consumers, immutably and irrevocably represent the interests of their creators. In particular, we provide a mechanism for data providers to control the use of their data through automatic verification of data consumer contracts, allowing providers to express constraints such as pricing and differential privacy. Through smart contracts and trusted execution environments, Sterling enables privacy-preserving analytics and machine learning over private data in an efficient manner. The resulting economy ensures that the interests of all parties are aligned.For the demonstration, we highlight the use of Sterling for training machine learning models on individuals' health data. In doing so, we showcase novel approaches to automatically appraising training data, verifying and enforcing model privacy properties, and efficiently training private models on the blockchain using trusted hardware.},
	number = {12},
	journal = {Proc. VLDB Endow.},
	author = {Hynes, Nick and Dao, David and Yan, David and Cheng, Raymond and Song, Dawn},
	month = aug,
	year = {2018},
	note = {Publisher: VLDB Endowment},
	pages = {2086--2089},
}

@inproceedings{third_linked_2017,
	address = {Republic and Canton of Geneva, CHE},
	series = {{WWW} '17 {Companion}},
	title = {Linked {Data} {Indexing} of {Distributed} {Ledgers}},
	isbn = {978-1-4503-4914-7},
	url = {https://doi.org/10.1145/3041021.3053895},
	doi = {10.1145/3041021.3053895},
	abstract = {Searching for information in distributed ledgers is currently not an easy task, as information relating to an entity may be scattered throughout the ledger with no index. As distributed ledger technologies become more established, they will increasingly be used to represent real world transactions involving many parties and the search requirements will grow. An index providing the ability to search using domain specific terms across multiple ledgers will greatly enhance to power, usability and scope of these systems.We have implemented a semantic index to the Ethereum blockchain platform, to expose distributed ledger data as Linked Data. As well as indexing block- and transaction-level data according to the BLONDiE ontology, we have mapped smart contracts to the Minimal Service Model ontology, to take the first steps towards connecting smart contracts with Semantic Web Services.},
	booktitle = {Proceedings of the 26th {International} {Conference} on {World} {Wide} {Web} {Companion}},
	publisher = {International World Wide Web Conferences Steering Committee},
	author = {Third, Allan and Domingue, John},
	year = {2017},
	note = {event-place: Perth, Australia},
	keywords = {distributed ledgers, linked data, blockchains, semantic indexing},
	pages = {1431--1436},
}

@article{tan_soltype_2022,
	title = {{SolType}: {Refinement} {Types} for {Arithmetic} {Overflow} in {Solidity}},
	volume = {6},
	url = {https://doi.org/10.1145/3498665},
	doi = {10.1145/3498665},
	abstract = {As smart contracts gain adoption in financial transactions, it becomes increasingly important to ensure that they are free of bugs and security vulnerabilities. Of particular relevance in this context are arithmetic overflow bugs, as integers are often used to represent financial assets like account balances. Motivated by this observation, this paper presents SolType, a refinement type system for Solidity that can be used to prevent arithmetic over- and under-flows in smart contracts. SolType allows developers to add refinement type annotations and uses them to prove that arithmetic operations do not lead to over- and under-flows. SolType incorporates a rich vocabulary of refinement terms that allow expressing relationships between integer values and aggregate properties of complex data structures. Furthermore, our implementation, called Solid, incorporates a type inference engine and can automatically infer useful type annotations, including non-trivial contract invariants. To evaluate the usefulness of our type system, we use Solid to prove arithmetic safety of a total of 120 smart contracts. When used in its fully automated mode (i.e., using Solid's type inference capabilities), Solid is able to eliminate 86.3\% of redundant runtime checks used to guard against overflows. We also compare Solid against a state-of-the-art arithmetic safety verifier called VeriSmart and show that Solid has a significantly lower false positive rate, while being significantly faster in terms of verification time.},
	number = {POPL},
	journal = {Proc. ACM Program. Lang.},
	author = {Tan, Bryan and Mariano, Benjamin and Lahiri, Shuvendu K. and Dillig, Isil and Feng, Yu},
	month = jan,
	year = {2022},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {smart contracts, integer overflow, refinement type inference},
}

@article{albert_taming_2020,
	title = {Taming {Callbacks} for {Smart} {Contract} {Modularity}},
	volume = {4},
	url = {https://doi.org/10.1145/3428277},
	doi = {10.1145/3428277},
	abstract = {Callbacks are an effective programming discipline for implementing event-driven programming, especially in environments like Ethereum which forbid shared global state and concurrency. Callbacks allow a callee to delegate the execution back to the caller. Though effective, they can lead to subtle mistakes principally in open environments where callbacks can be added in a new code. Indeed, several high profile bugs in smart contracts exploit callbacks. We present the first static technique ensuring modularity in the presence of callbacks and apply it to verify prominent smart contracts. Modularity ensures that external calls to other contracts cannot affect the behavior of the contract. Importantly, modularity is guaranteed without restricting programming. In general, checking modularity is undecidable—even for programs without loops. This paper describes an effective technique for soundly ensuring modularity harnessing SMT solvers. The main idea is to define a constructive version of modularity using commutativity and projection operations on program segments. We believe that this approach is also accessible to programmers, since counterexamples to modularity can be generated automatically by the SMT solvers, allowing programmers to understand and fix the error. We implemented our approach in order to demonstrate the precision of the modularity analysis and applied it to real smart contracts, including a subset of the 150 most active contracts in Ethereum. Our implementation decompiles bytecode programs into an intermediate representation and then implements the modularity checking using SMT queries. Overall, we argue that our experimental results indicate that the method can be applied to many realistic contracts, and that it is able to prove modularity where other methods fail.},
	number = {OOPSLA},
	journal = {Proc. ACM Program. Lang.},
	author = {Albert, Elvira and Grossman, Shelly and Rinetzky, Noam and Rodríguez-Núñez, Clara and Rubio, Albert and Sagiv, Mooly},
	month = nov,
	year = {2020},
	note = {Place: New York, NY, USA
Publisher: Association for Computing Machinery},
	keywords = {blockchain, smart contracts, program analysis, invariants, logic and verification, program verification},
}

@inproceedings{eklund_factors_2020,
	address = {New York, NY, USA},
	series = {{MEDES} '19},
	title = {Factors {That} {Impact} {Blockchain} {Scalability}},
	isbn = {978-1-4503-6238-2},
	url = {https://doi.org/10.1145/3297662.3365818},
	doi = {10.1145/3297662.3365818},
	abstract = {Blockchain systems (more precisely Distributed Ledger Technologies (DLTs)) represent a different digital ecosystem compared with traditional computer systems. One major difference are the performance and scalability factors which will be discussed and analytically investigated in this paper. In doing so, we provide guidance for defining a research agenda focusing on the investigation of the crucial role of scalability for blockchain systems. System performance – measured in terms of (1) consensus response time (blockchain network latency or time to convergence/agreement); (2) number of transactions per second or throughput, and (3) computing (and power) resources consumed – can be understood by considering the design dimensions of a blockchain system, namely: (i) the type of blockchain system needed from a requirements perspective which in turn determines; (ii) the complexity of the consensus protocol used; (iii) the topography of the traffic flow on the network; (iv) the performance and complexity of the domain-specific language that implements smart contracts; and (v) by the anticipated growth in size and complexity of the distributed ledger itself.},
	booktitle = {Proceedings of the 11th {International} {Conference} on {Management} of {Digital} {EcoSystems}},
	publisher = {Association for Computing Machinery},
	author = {Eklund, Peter W. and Beck, Roman},
	year = {2020},
	note = {event-place: Limassol, Cyprus},
	keywords = {blockchain, distributed ledger, distributed network scalability, survey of system performance},
	pages = {126--133},
}

@inproceedings{schlund_ethome_2018,
	address = {New York, NY, USA},
	series = {e-{Energy} '18},
	title = {{ETHome}: {Open}-{Source} {Blockchain} {Based} {Energy} {Community} {Controller}},
	isbn = {978-1-4503-5767-8},
	url = {https://doi.org/10.1145/3208903.3208929},
	doi = {10.1145/3208903.3208929},
	abstract = {This paper describes the proof of concept of a blockchain based organization of a local low voltage energy community. The focus of the concept is efficient use of shared resources to minimize external dependence, and not energy trading. A previously proposed control algorithm, which exploits the power dependency of the efficiency of electrical energy storages, is implemented as a smart contract on a private instance of an Ethereum blockchain to coordinate the operation. It is implemented using four connected Raspberry Pis representing the participating households with pre-given electrical load and photovoltaic conversion as well as a battery. Each household runs an Ethereum full node and an interfacing software. Only the energy technology components are simulated, while the blockchain is actually running on the Raspberry Pis in order to mind the full complexity of the technology. The practicability is proved in a test run and positive effects on the efficiency and the self-sufficiency within the community are observed. A first cost-benefit estimate is given and a further research agenda is presented.},
	booktitle = {Proceedings of the {Ninth} {International} {Conference} on {Future} {Energy} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Schlund, Jonas and Ammon, Lorenz and German, Reinhard},
	year = {2018},
	note = {event-place: Karlsruhe, Germany},
	keywords = {blockchain, open-source, battery efficiency, energy community},
	pages = {319--323},
}

@inproceedings{shahriar_nftgan_2022,
	address = {New York, NY, USA},
	series = {{ICMLT} 2022},
	title = {{NFTGAN}: {Non}-{Fungible} {Token} {Art} {Generation} {Using} {Generative} {Adversarial} {Networks}},
	isbn = {978-1-4503-9574-8},
	url = {https://doi.org/10.1145/3529399.3529439},
	doi = {10.1145/3529399.3529439},
	abstract = {Digital arts have gained an unprecedented level of popularity with the emergence of non-fungible tokens (NFTs). NFTs are cryptographic assets that are stored on blockchain networks and represent a digital certificate of ownership that cannot be forged. NFTs can be incorporated into a smart contract which allows the owner to benefit from a future sale percentage. While digital art producers can benefit immensely with NFTs, their production is time consuming. Therefore, this paper explores the possibility of using generative adversarial networks (GANs) for automatic generation of digital arts. GANs are deep learning architectures that are widely and effectively used for synthesis of audio, images, and video contents. However, their application to NFT arts have been limited. In this paper, a GAN-based architecture is implemented and evaluated for novel NFT-style digital arts generation. Results from the qualitative case study indicate that the generated artworks are comparable to the real samples in terms of being interesting and inspiring and they were judged to be more innovative than real samples.},
	booktitle = {2022 7th {International} {Conference} on {Machine} {Learning} {Technologies} ({ICMLT})},
	publisher = {Association for Computing Machinery},
	author = {Shahriar, Sakib and Hayawi, Kadhim},
	year = {2022},
	note = {event-place: Rome, Italy},
	keywords = {blockchain, adversarial networks, deep learning, digital art generation, NFT},
	pages = {255--259},
}

@inproceedings{cui_zero-shot_2022,
	address = {New York, NY, USA},
	series = {{ICPC} '22},
	title = {Zero-{Shot} {Program} {Representation} {Learning}},
	isbn = {978-1-4503-9298-3},
	url = {https://doi.org/10.1145/3524610.3527888},
	doi = {10.1145/3524610.3527888},
	abstract = {Learning program representations has been the core prerequisite of code intelligence tasks (e.g., code search and code clone detection). The state-of-the-art pre-trained models such as CodeBERT require the availability of large-scale code corpora. However, gathering training samples can be costly and infeasible for domain-specific languages such as Solidity for smart contracts. In this paper, we propose Zecoler, a zero-shot learning approach for code representations. Zecoler is built upon a pre-trained programming language model. In order to elicit knowledge from the pre-trained models efficiently, Zecoler casts the downstream tasks to the same form of pre-training tasks by inserting trainable prompts into the original input. Then, it employs the prompt learning technique to optimize the pre-trained model by merely adjusting the original input. This enables the representation model to efficiently fit the scarce task-specific data while reusing pre-trained knowledge. We evaluate Zecoler in three code intelligence tasks in two programming languages that have no training samples, namely, Solidity and Go, with model trained in corpora of common languages such as Java. Experimental results show that our approach significantly outperforms baseline models in both zero-shot and few-shot settings.},
	booktitle = {Proceedings of the 30th {IEEE}/{ACM} {International} {Conference} on {Program} {Comprehension}},
	publisher = {Association for Computing Machinery},
	author = {Cui, Nan and Jiang, Yuze and Gu, Xiaodong and Shen, Beijun},
	year = {2022},
	note = {event-place: Virtual Event},
	keywords = {code intelligence, learning program representations, prompt learning, zero-shot learning},
	pages = {60--70},
}

@inproceedings{marchesi_agile_2018,
	address = {New York, NY, USA},
	series = {{CEE}-{SECR} '18},
	title = {An {Agile} {Software} {Engineering} {Method} to {Design} {Blockchain} {Applications}},
	isbn = {978-1-4503-6176-7},
	url = {https://doi.org/10.1145/3290621.3290627},
	doi = {10.1145/3290621.3290627},
	abstract = {Cryptocurrencies and their foundation technology, the Blockchain, are reshaping finance and economics, allowing a decentralized approach enabling trusted applications with no trusted counterpart. More recently, the Blockchain and the programs running on it, called Smart Contracts, are also finding more and more applications in all fields requiring trust and sound certifications. Some people have come to the point of saying that the "Blockchain revolution" can be compared to that of the Internet and the Web in their early days. As a result, all the software development revolving around the Blockchain technology is growing at a staggering rate. The feeling of many software engineers about such huge interest in Blockchain technologies is that of unruled and hurried software development, a sort of competition on a first-come-first-served basis which does not assure neither software quality, nor that the basic concepts of software engineering are taken into account.This paper tries to cope with this issue, proposing a software development process to gather the requirement, analyze, design, develop, test and deploy Blockchain applications. The process is based on several Agile practices, such as User Stories and iterative and incremental development based on them. However, it makes also use of more formal notations, such as some UML diagrams describing the design of the system, with additions to represent specific concepts found in Blockchain development. The method is described in good detail, and an example is given to show how it works.},
	booktitle = {Proceedings of the 14th {Central} and {Eastern} {European} {Software} {Engineering} {Conference} {Russia}},
	publisher = {Association for Computing Machinery},
	author = {Marchesi, Michele and Marchesi, Lodovica and Tonelli, Roberto},
	year = {2018},
	note = {event-place: Moscow, Russian Federation},
	keywords = {Blockchain, Smart Contracts, UML, Blockchain-oriented software engineering, dApp design},
}
